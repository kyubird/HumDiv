######## LOADING LIBRARIES AND FUNCTIONS ########
#### Load libraries
library(stats4)
library(xlsx)
library(ggplot2)
library(iNEXT)
library(gvlma)
library(MuMIn)
library(zoo)
library(xts)
library(PerformanceAnalytics)
library(indicspecies)
library(carData)
library(car)
library(ecodist)
library(lattice)
library(vegan)
library(hillR)
library(knitr)
library(kableExtra)
library(beepr)
library(MASS)
library(olsrr)
library(tidyverse)
library(dplyr)
# Spatial libraries
## Load spatial libraries
library(sp)
library(maptools)
library(ggmap)
library(rgdal)
library(raster)
library(rgeos)
library(ggspatial)
# Set wd
setwd("C:\\Users\\nerc-user\\OneDrive\\Documents\\GitHub\\HumDiv")
# formatting to html so that complex tables can be used
options(knitr.table.format = "html")
di2 = function (x, datatype = "abundance") {
TYPE <- c("abundance", "incidence", "incidence_freq",
"incidence_raw")
if (is.na(pmatch(datatype, TYPE)))
stop("invalid datatype")
if (pmatch(datatype, TYPE) == -1)
stop("ambiguous datatype")
datatype <- match.arg(datatype, TYPE)
if (datatype == "incidence_freq")
datatype <- "incidence"
if (datatype == "incidence_raw") {
if (class(x) == "list") {
x <- lapply(x, as.incfreq)
}
else {
x <- as.incfreq(x)
}
datatype <- "incidence"
}
Fun.abun <- function(x) {
n <- sum(x)
fk <- sapply(1:10, function(k) sum(x == k))
f1 <- fk[1]
f2 <- fk[2]
Sobs <- sum(x > 0)
f0.hat <- ifelse(f2 == 0, (n - 1)/n * f1 * (f1 - 1)/2,
(n - 1)/n * f1^2/2/f2)
A <- ifelse(f1 > 0, n * f0.hat/(n * f0.hat + f1), 1)
Chat <- round(1 - f1/n * A, 4)
ME_CHANGE <- 1 - (1 - Chat) * exp(-2*f2/f1)
ME_CHANGE <- ifelse(is.nan(ME_CHANGE), 1.0000000, ME_CHANGE)
c(n, Sobs, Chat, ME_CHANGE, fk)
}
Fun.ince <- function(x) {
nT <- x[1]
x <- x[-1]
U <- sum(x)
Qk <- sapply(1:10, function(k) sum(x == k))
Q1 <- Qk[1]
Q2 <- Qk[2]
Sobs <- sum(x > 0)
Q0.hat <- ifelse(Q2 == 0, (nT - 1)/nT * Q1 * (Q1 - 1)/2,
(nT - 1)/nT * Q1^2/2/Q2)
A <- ifelse(Q1 > 0, nT * Q0.hat/(nT * Q0.hat + Q1), 1)
Chat <- round(1 - Q1/U * A, 4)
out <- c(nT, U, Sobs, Chat, Qk)
}
if (datatype == "abundance") {
if (class(x) == "numeric" | class(x) == "integer") {
out <- matrix(Fun.abun(x), nrow = 1)
}
else if (class(x) == "list") {
out <- do.call("rbind", lapply(x, Fun.abun))
}
else if (class(x) == "matrix" | class(x) == "data.frame") {
out <- t(apply(as.matrix(x), 2, Fun.abun))
}
if (nrow(out) > 1) {
out <- data.frame(site = rownames(out), out)
colnames(out) <- c("site", "n", "S.obs",
"SC", "SC2", paste("f", 1:10, sep = ""))
rownames(out) <- NULL
}
else {
out <- data.frame(site = "site.1", out)
colnames(out) <- c("site", "n", "S.obs",
"SC", "SC2", paste("f", 1:10, sep = ""))
}
as.data.frame(out)
}
else if (datatype == "incidence") {
if (class(x) == "numeric" | class(x) == "integer") {
out <- matrix(Fun.ince(x), nrow = 1)
}
else if (class(x) == "list") {
out <- do.call("rbind", lapply(x, Fun.ince))
}
else if (class(x) == "matrix" | class(x) == "data.frame") {
out <- t(apply(as.matrix(x), 2, Fun.ince))
}
if (nrow(out) > 1) {
out <- data.frame(site = rownames(out), out)
colnames(out) <- c("site", "T", "U",
"S.obs", "SC", paste("Q", 1:10,
sep = ""))
rownames(out) <- NULL
}
else {
out <- data.frame(site = "site.1", out)
colnames(out) <- c("site", "T", "U",
"S.obs", "SC", paste("Q", 1:10,
sep = ""))
}
as.data.frame(out)
}
}
gginext2 = function (x, type = 1, se = FALSE, facet.var = "none", color.var = "site", grey = FALSE) {
TYPE <- c(1, 2, 3)
SPLIT <- c("none", "order", "site", "both")
if (is.na(pmatch(type, TYPE)) | pmatch(type, TYPE) == -1)
stop("invalid plot type")
if (is.na(pmatch(facet.var, SPLIT)) | pmatch(facet.var, SPLIT) ==
-1)
stop("invalid facet variable")
if (is.na(pmatch(color.var, SPLIT)) | pmatch(color.var, SPLIT) ==
-1)
stop("invalid color variable")
type <- pmatch(type, 1:3)
facet.var <- match.arg(facet.var, SPLIT)
color.var <- match.arg(color.var, SPLIT)
if (facet.var == "order")
color.var <- "site"
if (facet.var == "site")
color.var <- "order"
options(warn = -1)
z <- fortify(x, type = type)
options(warn = 0)
if (ncol(z) == 7) {
se <- FALSE
}
datatype <- unique(z$datatype)
if (color.var == "none") {
if (levels(factor(z$order)) > 1 & "site" %in% names(z)) {
warning("invalid color.var setting, the iNEXT object consists multiple sites and orders, change setting as both")
color.var <- "both"
z$col <- z$shape <- paste(z$site, z$order, sep = "-")
}
else if ("site" %in% names(z)) {
warning("invalid color.var setting, the iNEXT object consists multiple orders, change setting as order")
color.var <- "site"
z$col <- z$shape <- z$site
}
else if (levels(factor(z$order)) > 1) {
warning("invalid color.var setting, the iNEXT object consists multiple sites, change setting as site")
color.var <- "order"
z$col <- z$shape <- factor(z$order)
}
else {
z$col <- z$shape <- rep(1, nrow(z))
}
}
else if (color.var == "order") {
z$col <- z$shape <- factor(z$order)
}
else if (color.var == "site") {
if (!"site" %in% names(z)) {
warning("invalid color.var setting, the iNEXT object do not consist multiple sites, change setting as order")
z$col <- z$shape <- factor(z$order)
}
z$col <- z$shape <- z$site
}
else if (color.var == "both") {
if (!"site" %in% names(z)) {
warning("invalid color.var setting, the iNEXT object do not consist multiple sites, change setting as order")
z$col <- z$shape <- factor(z$order)
}
z$col <- z$shape <- paste(z$site, z$order, sep = "-")
}
zz = z
z$method[z$method == "observed"] = "interpolated"
z$lty <- z$lty <- factor(z$method, levels = unique(c("interpolated",
"extrapolated"), c("interpolation", "interpolation",
"extrapolation")))
z$col <- factor(z$col)
data.sub <- zz[which(zz$method == "observed"), ]
g <- ggplot(z, aes_string(x = "x", y = "y", colour = "col")) +
geom_point(aes_string(shape = "shape"), size = 5,
data = data.sub)
g <- g + geom_line(aes_string(linetype = "lty"), lwd = 1.5) +
guides(linetype = guide_legend(title = "Method"),
colour = guide_legend(title = "Guides"), fill = guide_legend(title = "Guides"),
shape = guide_legend(title = "Guides")) + theme(legend.position = "bottom",
legend.title = element_blank(), text = element_text(size = 18),
legend.key.width = unit(1.2, "cm"))
if (type == 2L) {
g <- g + labs(x = "Number of sampling units", y = "Sample coverage")
if (datatype == "abundance")
g <- g + labs(x = "Number of individuals",
y = "Sample coverage")
}
else if (type == 3L) {
g <- g + labs(x = "Sample coverage", y = "Species diversity")
}
else {
g <- g + labs(x = "Number of sampling units", y = "Species diversity")
if (datatype == "abundance")
g <- g + labs(x = "Number of individuals",
y = "Species diversity")
}
if (facet.var == "order") {
if (length(levels(factor(z$order))) == 1 & type != 2) {
warning("invalid facet.var setting, the iNEXT object do not consist multiple orders.")
}
else {
g <- g + facet_wrap(~order, nrow = 1)
if (color.var == "both") {
g <- g + guides(colour = guide_legend(title = "Guides",
ncol = length(levels(factor(z$order))), byrow = TRUE),
fill = guide_legend(title = "Guides"))
}
}
}
if (facet.var == "site") {
if (!"site" %in% names(z)) {
warning("invalid facet.var setting, the iNEXT object do not consist multiple sites.")
}
else {
g <- g + facet_wrap(~site, nrow = 1)
if (color.var == "both") {
g <- g + guides(colour = guide_legend(title = "Guides",
nrow = length(levels(factor(z$order)))), fill = guide_legend(title = "Guides"))
}
}
}
if (facet.var == "both") {
if (length(levels(factor(z$order))) == 1 | !"site" %in%
names(z)) {
warning("invalid facet.var setting, the iNEXT object do not consist multiple sites or orders.")
}
else {
g <- g + facet_wrap(site ~ order)
if (color.var == "both") {
g <- g + guides(colour = guide_legend(title = "Guides",
nrow = length(levels(factor(z$site))), byrow = TRUE),
fill = guide_legend(title = "Guides"))
}
}
}
if (grey) {
g <- g + theme_bw(base_size = 18) + scale_fill_grey(start = 0,
end = 0.4) + scale_colour_grey(start = 0.2, end = 0.2) +
guides(linetype = guide_legend(title = "Method"),
colour = guide_legend(title = "Guides"),
fill = guide_legend(title = "Guides"),
shape = guide_legend(title = "Guides")) +
theme(legend.position = "bottom", legend.title = element_blank())
}
g <- g + theme(legend.box = "vertical") + theme(legend.position = "none")
return(g)
}
# 1.  Reading in the capture data
fcat.hum = read.csv(file = "...\\Captures_2004_2017_Final_(MSE).csv", na.strings=c(""," ","NA"))
# 1.  Reading in the capture data
fcat.hum = read.csv(file = ".\\Captures_2004_2017_Final_(MSE).csv", na.strings=c(""," ","NA"))
# 1.  Reading in the data.
env.cov = read.csv(".\\Habitat_final_2017_MSE_21Dec2019.csv", na.strings=c(""," ","NA"))
# 2.  Subsetting to select useful columns
colnames(fcat.hum)
fcat.hum = dplyr::select(fcat.hum, Fragmento, Locacion, Fecha, No.Anillo, Recap, Occasion, Year, EnglName.SACC, Guild_2, Family.SACC, Notas)
# 3.  Changing column names to make them easier to work with
fcat.hum = fcat.hum %>% dplyr::rename(forest = Fragmento, site = Locacion, date = Fecha, band.number = No.Anillo, recap = Recap, samp.per = Occasion, year = Year, species = EnglName.SACC, guild = Guild_2, family = Family.SACC, notes = Notas)
fcat.hum$site.year = paste(fcat.hum$site,fcat.hum$year, sep = "_")
fcat.hum$s.y.sp = paste(fcat.hum$site, fcat.hum$year, fcat.hum$samp.per, sep = "_")
fcat.hum$species = toupper(fcat.hum$species)
fcat.hum$species = as.factor(fcat.hum$species)
levels(fcat.hum$species)
levels(fcat.hum$species)[levels(fcat.hum$species) == "BROWN-WINGED SCHIFFORNIS"] = "NORTHERN SCHIFFORNIS"
levels(fcat.hum$species)[levels(fcat.hum$species) == "BLUE-LORED ANTBIRD"] = "ZELEDON'S ANTBIRD"
levels(fcat.hum$species)[levels(fcat.hum$species) == "HALF-COLLARED GNATWREN"] = "TAWNY-FACED GNATWREN"
levels(fcat.hum$species)[levels(fcat.hum$species) == "RED-EYED VIREO"] = "CHIVI VIREO"
levels(fcat.hum$species)[levels(fcat.hum$species) == "CHESTNUT-CAPPED BRUSH FINCH"] = "CHESTNUT-CAPPED BRUSHFINCH"
levels(fcat.hum$species)[levels(fcat.hum$species) == "GOLDEN-FACED TYRANNULET"] = "CHOCO TYRANNULET"
# 6.  Checking the guilds to make sure they're okay.
levels(fcat.hum$guild)
levels(fcat.hum$guild)[levels(fcat.hum$guild) == "Piscívoros or ictiófagos"] = "Piscivore"
levels(fcat.hum$guild)[levels(fcat.hum$guild) == "Vegetarian"] = "Herbivore"
levels(fcat.hum$guild)[levels(fcat.hum$guild) == "Insectivore "] = "Insectivore"
# 7.  Checking families for typos. Will need to do a deeper dive at some point to make sure species are properly classified into the right families following most recent SACC updates.
levels(fcat.hum$family) # Looks good!
# 8a. First of all, how many band numbers do we have?
bands = data.frame(levels(fcat.hum$band.number))
bands
View(fcat.hum)
# 8b. Getting rid of the spaces. Need to make sure we still have the same number of bands. There will likely be less after. For example if there are two bands, DD 123 and DD123, in the dataset, they would get combined to DD123. However, if that's the same individual, the second instance should appear as a recapture regardless of any typos in the band number. Need to cross reference with NEW captures to find any problems.
fcat.hum$band.number = gsub('\\s+', '', fcat.hum$band.number)
fcat.hum$band.number = as.factor(fcat.hum$band.number)
bands2 = data.frame(levels(fcat.hum$band.number)) # Now we're down to 6,759 (lost 35)
rm(bands, bands2)
# 9.  Adding hummingbird Y/N and banded (Y/N) columns to easily separate our focal groups from the rest. Also turning recap into Y/N. This will come in handy later!
fcat.hum$hummer = NA
fcat.hum$hummer = ifelse(fcat.hum$family == "Trochilidae", "Y", "N")
fcat.hum$hummer = as.factor(fcat.hum$hummer)
fcat.hum$banded = NA
fcat.hum$banded = ifelse(is.na(fcat.hum$band.number), "N", "Y")
fcat.hum$banded = as.factor(fcat.hum$banded)
fcat.hum$recap = as.character(fcat.hum$recap)
fcat.hum$recap[is.na(fcat.hum$recap)] = "N"
fcat.hum$recap = as.factor(fcat.hum$recap)
# 10. We turned the Fragmento column into 'forest.' Let's change those NAs to BBS
fcat.hum$forest = factor(fcat.hum$forest, levels = c("Fragment", "BBS"))
fcat.hum$forest = fcat.hum$forest %>% replace_na("BBS")
# 11. Creating a season column to check for differences between wet and dry season.
fcat.hum$season = ifelse(grepl("Jan", fcat.hum$date) | grepl("Feb", fcat.hum$date) | grepl("Mar", fcat.hum$date) | grepl("Apr", fcat.hum$date) | grepl("May", fcat.hum$date) | grepl("Jun", fcat.hum$date) | grepl("Jul", fcat.hum$date), "wet", "dry")
# 12. Filtering out everything before 2013
fcat.hum = fcat.hum %>%
filter(year >= 2013) %>%
droplevels()
View(fcat.hum)
# 1.  Let's take a deeper dive into our unbanded birds.
# 1a. Creating a new dataset for the unbanded nonhummers in 2014 & 2015.
unbanded = subset(fcat.hum, banded == "N" & hummer == "N")
# 2b. Tallying up occurrences of each species
unbanded.spp = arrange(full_join(unbanded %>%
group_by(species) %>%
dplyr::summarize(no_rows = length(species)), fcat.hum %>% group_by(species) %>%
dplyr::summarize(no_rows = length(species)), by = "species"), desc(no_rows.x))
unbanded.spp = unbanded.spp %>%
dplyr::rename(unbanded = no_rows.x, total.caught = no_rows.y) %>%
mutate(percent.unbanded = unbanded/total.caught *100)
# 2c. Let's figure out where these guys were coming from. Maybe we won't need them.
unbanded$site = droplevels(unbanded$site)
levels(unbanded$site)
unbanded = unbanded %>% group_by(site) %>% dplyr::summarize(no_rows = length(site))
View(unbanded$site)
View(unbanded)
levels(unbanded$site)
unbanded = unbanded %>% group_by(site) %>% dplyr::summarize(no_rows = length(site))
# 2d. Removing those datasets since we won't need them again.
rm(unbanded, unbanded.spp)
# 3b. Checking to see what species are unbanded recaptures.
unbanded.recaps = fcat.hum %>%
filter(recap == "Y" & is.na(fcat.hum$band.number)) %>%
group_by(species) %>%
dplyr::summarize(n = length(species))
